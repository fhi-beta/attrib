---
title: "Introduction to Attrib"
author: "Aurora Hofman"
date: "2020-02-20"
output: rmarkdown::html_vignette
vignette: >
 %\VignetteIndexEntry{Introduction to Attrib}
 %\VignetteEncoding{UTF-8}
 %\VignetteEngine{knitr::rmarkdown}
editor_options:
chunk_output_type: console
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(attrib)
```

# Introduciton
Attrib provides a way of estimating what the mortality would have been it some given exposures are set to a referance value. 

This example will go throug how to use fit_attrib to fit the datam how to use est_attrib to estimate the mortality given exposures and referance values and some examples of usages of the resulting dataset. 

## Data example

We will use the dataset fake_data which consists of fake date of mortalities for all municipalities of Norway on a weekly basis from 2010 untill 2020. The dataset consists of the followig variables:

* location_code: Location code of the differend municipalities
* week: Week number
* season: Years of the season
* x: Number of weeks from the start of the season
* pop: Population size
* pr100_ili: Percentage of doctorsconsultations diagnosed with influenza like ilnesses 
* pr100_ili_lag_1: pr_100_ili lagged wiht one week
* temperature: Temperature
* temperature_high: number of heatwaves
* deaths: number of mortalities 



```{r}
data_fake_county <- attrib::data_fake_county
data_fake_nation <- attrib::data_fake_norway
head(data_fake_county, 5)
```

In this example we will look at the exposures pr100_ili_lag_1 and temperature_high and calculate the attributable mortalities due to these exposures. 

# Fitting using fit_attrib on countylevel

We want to estimate the attributable mortality due to ILI and heatwaves. Attrib lets one fit models with both fixed and random effect and offsets. This means one must specify which are the offset, the fixed effects and the random effects. The response will be given with the fixed effexts. In our case we will model *deaths* as a function of:

* the fixed effects:
  * temperature_high
  * pr100_ili_lag_1
  * sin(2 * pi * (week - 1) / 52) 
  * cos(2 * pi * (week - 1) / 52)
* the random effects:
  * (1|location_code)
  * (pr100_ili_lag_1|season)
* the offset:
  * log(pop)

```{r}
# take in the fixed effects
fixef_county <- "deaths ~
  temperature_high +
  pr100_ili_lag_1 +
  sin(2 * pi * (week - 1) / 52) +
  cos(2 * pi * (week - 1) / 52)"


#take in the random effects
ranef_county <- "(1|location_code) +
  (pr100_ili_lag_1|season)"

# take in the offset
offset_county <- "log(pop)"

```

Now we fit the model using fit_attrib. 

```{r}
suppressWarnings(
  fit_county <- fit_attrib(data_fake_county, fixef = fixef_county, ranef = ranef_county, offset = offset_county)
)
```
```{r}
fit_county
```

Note that fit has the added attributes offset, saving the offset name, and fit_fix, the coefficients of the linear model fitted on only the fixed effects. These are needed by est_attrib later on. 

# Fitting using fit_attrib on a national level

We estimate the same as before put on a national level meaning we remove the random effect (1|location_code). This gives the following model:

* the fixed effects:
  * temperature_high
  * pr100_ili_lag_1
  * sin(2 * pi * (week - 1) / 52) 
  * cos(2 * pi * (week - 1) / 52)
* the random effects:
  * (pr100_ili_lag_1|season)
* the offset:
  * log(pop)

```{r}
# take in the fixed effects
fixef_nation <- "deaths ~
  temperature_high +
  pr100_ili_lag_1 +
  sin(2 * pi * (week - 1) / 52) +
  cos(2 * pi * (week - 1) / 52)"


#take in the random effects
ranef_nation <- "(pr100_ili_lag_1|season)"

# take in the offset
offset_nation <- "log(pop)"

```

Now we fit the model using fit_attrib. 

```{r}
suppressWarnings(
  fit_nation <- fit_attrib(data_fake_nation, fixef = fixef_nation, ranef = ranef_nation, offset = offset_nation)
)
```


# Estimating referance mortality using est_mort on both models

```{r}
response <- "deaths"
exposures <- list( "temperature_high" = 0, "pr100_ili_lag_1" = 0)
est_mort_sim_county <- attrib::est_mort(fit_county, data_fake_county, exposures = exposures, response = response )
est_mort_sim_nation <- attrib::est_mort(fit_nation, data_fake_nation, exposures = exposures, response = response )
```


```{r}
est_mort_county_long<-data.table::melt.data.table(est_mort_sim_county, id.vars = c("location_code", "season",  "x", "week", "id", "sim_id", "deaths", "exp_mort_observed"),
                                           measure.vars = c("exp_mort_temperature_high=0", "exp_mort_pr100_ili_lag_1=0")) 
data.table::setnames(est_mort_county_long, "variable", "attr")

head(est_mort_county_long, 5)
```
```{r}
est_mort_nation_long<-data.table::melt.data.table(est_mort_sim_nation, id.vars = c("location_code", "season",  "x", "week", "id", "sim_id", "deaths", "exp_mort_observed"),
                                           measure.vars = c("exp_mort_temperature_high=0", "exp_mort_pr100_ili_lag_1=0")) 
data.table::setnames(est_mort_nation_long, "variable", "attr")

head(est_mort_nation_long, 5)
```

# Aggregate from county to national level per season
```{r}
#remove weeks

aggregated_county_to_nation <-  est_mort_county_long[,.(
  exp_mort_observed = sum(exp_mort_observed),
  value = sum(value), 
  deaths = sum(deaths)
), keyby = .(season, attr, sim_id)]


aggregated_county_to_nation[, exp_attr:= (exp_mort_observed - value)]
aggregated_county_to_nation[, exp_irr:= (exp_mort_observed/value)]
aggregated_county_to_nation[, tag := "aggregated_from_county"]
```

# Aggregating the national model per season
```{r}
aggregated_nation <-  est_mort_nation_long[, .(
  exp_mort_observed = sum(exp_mort_observed),
  value = sum(value), 
  deaths = sum(deaths)
), keyby = .(season, attr, sim_id)]



aggregated_nation[, exp_attr:= (exp_mort_observed - value)]
aggregated_nation[, exp_irr:= (exp_mort_observed/value)]
aggregated_nation[, tag:= "nation"]

```

# Calculate quantiles for attributable mortality and IRR for both models
```{r}
library(ggplot2)
data_national<- data.table::rbindlist(list(aggregated_county_to_nation, aggregated_nation))
```

```{r}
#quantiles
q05 <- function(x){
  return(quantile(x, 0.05))
}
q95 <- function(x){
  return(quantile(x, 0.95))
}
```

```{r}
#remove simulations
col_names <- colnames(data_national)
data.table::setkeyv(data_national, col_names[!col_names %in% c("exp_attr", "exp_irr","sim_id", "exp_mort_observed", "value", "deaths")])

aggregated_sim_seasonal_data_national<- data_national[,
                                   unlist(recursive = FALSE, lapply(.(median = median, q05 = q05, q95 = q95),
                                                                    function(f) lapply(.SD, f)
                                   )), 
                                   by = eval(data.table::key(data_national)),
                                   .SDcols = c("exp_attr", "exp_irr")]

```

# Plot to compare the two models
```{r}
q <- ggplot(aggregated_sim_seasonal_data_national[attr == "exp_mort_pr100_ili_lag_1=0"], 
                       aes(x = season, y = median.exp_attr, group = tag, color = tag)) 
q <- q + geom_pointrange(aes(x = season, y = median.exp_attr, ymin = q05.exp_attr, ymax = q95.exp_attr), position = position_dodge(width = 0.3))
q <- q + ggtitle("Attributable mortality due to ILI in Norway according to 2 models") 
q <- q +  scale_y_continuous("Estimated attributable mortality") 
q <- q +  theme(axis.text.x = element_text(angle = 90),axis.title.x=element_blank()) 
q <- q +  labs(caption = glue::glue(" Aggregated county model: Attributable mortality modeled on a county level before beeing aggregated up to a national level.\n National model: Attributable mortality modeled on a national level.\n Folkehelseinstituttet 14.07.2020"))
q

```

# Aggregating county model on weekly basis and adding cummulativ informaiton per season
Cumulativ per season
```{r}
aggregated_county_to_nation <-  est_mort_county_long[, .(
  exp_mort_observed = sum(exp_mort_observed),
  value = sum(value), 
  deaths = sum(deaths)
), keyby = .(season, x, week, attr, sim_id)]

aggregated_county_to_nation[, exp_attr:= (exp_mort_observed - value)]
aggregated_county_to_nation[, exp_irr:= (exp_mort_observed/value)]

```


```{r}

col_names <- colnames(aggregated_county_to_nation)
data.table::setkeyv(aggregated_county_to_nation, col_names[!col_names %in% c("exp_attr", "exp_irr","sim_id", "exposures", "exp_mort_observed", "value")])

aggregated_county_to_nation_weekly <- aggregated_county_to_nation[,
              unlist(recursive = FALSE, lapply(.(median = median, q05 = q05, q95 = q95),
                                               function(f) lapply(.SD, f)
              )), 
              by=eval(data.table::key(aggregated_county_to_nation)),
              .SDcols = c("exp_attr", "exp_irr")]
```
```{r}
aggregated_county_to_nation_weekly[, cumsum := cumsum(median.exp_attr), by = .( attr, season)]
aggregated_county_to_nation_weekly[, cumsum_q05 := cumsum(q05.exp_attr), by = .( attr, season)]
aggregated_county_to_nation_weekly[, cumsum_q95 := cumsum(q95.exp_attr), by = .( attr, season)]

```

# Cumulativ plot for ILI 
```{r}
library(ggplot2)
q <-ggplot(data = aggregated_county_to_nation_weekly[season %in% c("2015/2016", "2016/2017", "2017/2018", "2018/2019","2019/2020") & attr == "exp_mort_pr100_ili_lag_1=0"], aes(x = x, y = cumsum, group = season, color = season, fill = season)) 
q <- q +  geom_line() 
q <- q + geom_ribbon(data = aggregated_county_to_nation_weekly[season %in% c("2019/2020") & attr == "exp_mort_pr100_ili_lag_1=0"],
                     aes(ymin = cumsum_q05, ymax = cumsum_q95), alpha = 0.4, colour = NA)

q <- q + scale_y_continuous("Estimated attributable mortality", breaks = fhiplot::pretty_breaks(5), labels = fhiplot::format_nor)
q <- q + fhiplot::scale_color_fhi(name = "Season")
q <- q + fhiplot::theme_fhi_lines_horizontal()
q <- q + ggtitle("Estimated mortality due to ILI in Norway")
q

```

#Plot for ILI
```{r}
q <- ggplot(data = aggregated_county_to_nation_weekly[attr == "exp_mort_pr100_ili_lag_1=0"], 
            aes(x = x, y = cumsum, group = season)) 
q <- q +  geom_line(data = aggregated_county_to_nation_weekly[season != "2019/2020" &attr == "exp_mort_pr100_ili_lag_1=0"], 
            aes(x = x, y = median.exp_attr, group = season), color = "grey")
q <- q +  geom_line(data = aggregated_county_to_nation_weekly[season == "2019/2020" &attr == "exp_mort_pr100_ili_lag_1=0"], 
            aes(x = x, y = median.exp_attr, group = season), color = "blue")
q <- q +  geom_ribbon(data = aggregated_county_to_nation_weekly[season == "2019/2020" &attr == "exp_mort_pr100_ili_lag_1=0"], 
              aes(x = x, ymin = q05.exp_attr, ymax = q95.exp_attr), fill = "blue", alpha=0.4)

q <- q + scale_y_continuous("Estimated attributable mortality", breaks = fhiplot::pretty_breaks(5), labels = fhiplot::format_nor)
q <- q + fhiplot::scale_color_fhi(name = "Season")
q <- q + fhiplot::theme_fhi_lines_horizontal()
q <- q + ggtitle("Estimated mortality due to ILI per week")
q
```




